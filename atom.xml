<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱健身,爱代码</title>
  
  <subtitle>健身改变自我,代码改变世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://acmen.club/"/>
  <updated>2019-09-10T04:10:11.914Z</updated>
  <id>http://acmen.club/</id>
  
  <author>
    <name>健身码农</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划相关算法</title>
    <link href="http://acmen.club/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
    <id>http://acmen.club/算法/动态规划相关算法/</id>
    <published>2019-09-09T03:15:14.000Z</published>
    <updated>2019-09-10T04:10:11.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。</p><hr><h1 id="求最长回文子串"><a href="#求最长回文子串" class="headerlink" title="求最长回文子串"></a>求最长回文子串</h1><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br></pre></td></tr></table></figure><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>求某个字符串的最长回文子串可分解为求该字符串子字符串的最长回文子串子问题，根据状态转移方程动态规划求得最终结果。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindromeSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()&lt;<span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="comment">// dp[i][j] 表示s.substring(i,j+1)是否为回文字符串</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        String longestSubstr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 动态规划求所有长度子串是否为回文字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;len;j++)&#123;</span><br><span class="line">               <span class="comment">// 若两端字符相等且s.substring(i+1,j)为回文字符串则s.substring(i,j+1)也为回文字符串</span></span><br><span class="line">               dp[i][j] = s.charAt(i)==s.charAt(j)&amp;&amp;(j-i&lt;<span class="number">3</span>||dp[i+<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">               <span class="comment">// 若s.substring(i,j+1)为回文字符串且长度大于之前长度，最长回文字符串设为当前字符串</span></span><br><span class="line">               <span class="keyword">if</span>(dp[i][j]&amp;&amp;(longestSubstr==<span class="keyword">null</span>||j-i+<span class="number">1</span>&gt;longestSubstr.length()))&#123;</span><br><span class="line">                   longestSubstr = s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longestSubstr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="求最长回文子序列"><a href="#求最长回文子序列" class="headerlink" title="求最长回文子序列"></a>求最长回文子序列</h1><h2 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h2><p>求某个字符串的最长回文子序列不要求结果字符连续，同样可分解为求该字符串子字符串的最长回文子序列子问题，根据状态转移方程动态规划求得最终结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbab&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><h2 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h2><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           <span class="comment">// 设置初始状态</span></span><br><span class="line">           dp[i][i] = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">               <span class="comment">// 若两端字符相等则在s.substring(i+1,j)的最长回文子序列长度基础上+2</span></span><br><span class="line">               <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                   dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="comment">// 否则，s.substring(i,j+1)的最长回文子序列长度为s.substring(i+1,j+1)与s.substring(i,j)的最长回文子序列长度较大值</span></span><br><span class="line">                   dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>],dp[i+<span class="number">1</span>][j]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。2
      
    
    </summary>
    
      <category term="算法" scheme="http://acmen.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://acmen.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>一行一行源码分析清楚ThreadLocal</title>
    <link href="http://acmen.club/uncategorized/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9AThreadLocal/"/>
    <id>http://acmen.club/uncategorized/一行一行源码分析清楚ThreadLocal/</id>
    <published>2019-08-27T07:12:34.000Z</published>
    <updated>2019-08-27T07:12:34.049Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树相关算法</title>
    <link href="http://acmen.club/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
    <id>http://acmen.club/数据结构与算法/二叉树相关算法/</id>
    <published>2019-08-14T14:46:43.000Z</published>
    <updated>2019-09-09T03:08:22.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>树是计算机领域经常用到的一种数据结构，因为树的定义是递归的，因此，树相关的算法也大都涉及到递归求解。树有很多种类型，如二叉树、BST树、红黑树、B树、B+树等。二叉树结构比较简单，大部分算法都与二叉树相关。下面，我们针对二叉树的常见算法进行一一解析。后面的算法都要用到树节点的定义，因此我们对树节点进行统一定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">     int val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="先、中、后序遍历二叉树"><a href="#先、中、后序遍历二叉树" class="headerlink" title="先、中、后序遍历二叉树"></a>先、中、后序遍历二叉树</h1><p>树的遍历一般都有两种解法——迭代与递归。递归解法简单明了但递归栈的使用易造成空间复杂度过高。迭代解法虽然代码多但不会消耗太多的空间。开发时推荐使用迭代算法，尽量避免采用递归算法。</p><h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><ul><li>迭代版：</li></ul><p>先序遍历树的顺序为root-&gt;left-&gt;right。迭代时先将根节点压栈，然后开始循环迭代，先访问出栈节点，然后再将右子节点压栈，再将左子节点压栈，然后再重复出栈访问，直至栈为空。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><ul><li>迭代版：</li></ul><p>中序遍历树的顺序为left-&gt;root-&gt;right。直接开始循环迭代，先将根节点压栈，再将所有左节点压栈，然后出栈访问栈顶节点，然后再将栈顶节点右子节点压栈，然后再重复迭代直至栈为空。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(root!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><ul><li>迭代版1：</li></ul><p>后序遍历树的顺序为left-&gt;right-&gt;root。迭代时先将根节点压栈，然后开始循环迭代，先访问出栈节点，需要注意的是这里为了满足最终的后续遍历顺序，每次出栈后需要将访问节点放到最前面，即插入到上一个访问节点的前面。然后再将右子节点压栈，再将左子节点压栈，然后再重复出栈访问，直至栈为空。严格意义上将这种方式并没有真正的进行后序遍历，只是利用了技巧得到了后序遍历序列而已。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="comment">// 每次将访问的几点插入到最前面</span></span><br><span class="line">        res.add(<span class="number">0</span>,root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迭代版2：</li></ul><p>此版本真正实现了二叉树的后序遍历。遍历过程采用节点双压策略，即每次入栈节点两次。整体思路如下：</p><ol><li>入栈根节点两次；</li><li>取当前栈顶节点作为当前节点，然后出栈 ；</li><li>若栈不为空且取出的栈顶节点与当前栈顶节点相等，若当前节点左右子节点不为空分别入栈右子节点两次，否则访问当前节点，将当前节点加入结果列表；</li><li>重复迭代，直至栈为空。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">// 入栈根节点两次</span></span><br><span class="line">    stack.push(root);</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">// 得到栈顶节点</span></span><br><span class="line">        TreeNode currNode = stack.peek();</span><br><span class="line">        <span class="comment">// 出栈一次</span></span><br><span class="line">        stack.pop();</span><br><span class="line">        <span class="comment">// 若当前节点与栈顶节点相等则继续压栈左右子节点</span></span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty()&amp;&amp;currNode == stack.peek())&#123;</span><br><span class="line">            <span class="keyword">if</span>(currNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(currNode.right);</span><br><span class="line">                stack.push(currNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(currNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(currNode.left);</span><br><span class="line">                stack.push(currNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 若当前节点与栈顶节点不相等说明节点左右子节点均已遍历完毕</span></span><br><span class="line">            res.add(currNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="序列化与反序列化一颗二叉树"><a href="#序列化与反序列化一颗二叉树" class="headerlink" title="序列化与反序列化一颗二叉树"></a>序列化与反序列化一颗二叉树</h1><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>给定一棵二叉树，实现方法对其进行序列化与反序列化。</p><blockquote><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树：</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">         / \   </span><br><span class="line">        4   5</span><br><span class="line">输出序列化结果：[1,2,3,null,null,4,5]。</span><br></pre></td></tr></table></figure><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>序列化时选择先序遍历顺序序列化二叉树，遇到空节点时设置特殊符号标识该位置为空节点。序列化过程中注意采用分隔符分隔各个节点。<br>反序列化时借助双端队列进行。每次头结点出队列，按照先序序列完成树的反序列化。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义分隔符与空节点标识符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SPLITER = <span class="string">","</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String NN = <span class="string">"X"</span>;</span><br><span class="line">    <span class="comment">// 序列化二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        serializeHelper(root,sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serializeHelper</span><span class="params">(TreeNode root,StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 若当前节点为空，添加空标识与分隔符至序列化结尾</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(NN+SPLITER);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加当前节点值与分隔符至末尾</span></span><br><span class="line">        sb.append(root.val+SPLITER);</span><br><span class="line">        <span class="comment">// 递归序列化左子树</span></span><br><span class="line">        serializeHelper(root.left,sb);</span><br><span class="line">        <span class="comment">// 递归序列化右子树</span></span><br><span class="line">        serializeHelper(root.right,sb);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反序列化字符串为二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String[] strs = data.split(SPLITER);</span><br><span class="line">        Deque&lt;String&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加所有节点值至双端队列</span></span><br><span class="line">        deque.addAll(Arrays.asList(strs));</span><br><span class="line">        <span class="keyword">return</span> deserializeHelper(deque);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">deserializeHelper</span><span class="params">(Deque&lt;String&gt; nodes)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 取双端队列头节点</span></span><br><span class="line">        String val = nodes.remove();</span><br><span class="line">        <span class="comment">// 若当前头结点值为空节点标识，则返回空</span></span><br><span class="line">        <span class="keyword">if</span>(val.equals(NN))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据头节点值构造树节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(val));</span><br><span class="line">        <span class="comment">// 递归反序列化左子树序列</span></span><br><span class="line">        root.left = deserializeHelper(nodes);</span><br><span class="line">        <span class="comment">// 递归反序列化右子树序列</span></span><br><span class="line">        root.right = deserializeHelper(nodes);</span><br><span class="line">        <span class="comment">// 返回反序列化结果</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="判断一棵树是否为平衡二叉树"><a href="#判断一棵树是否为平衡二叉树" class="headerlink" title="判断一棵树是否为平衡二叉树"></a>判断一棵树是否为平衡二叉树</h1><h2 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h2><p>给定一颗树，判断其是否为平衡二叉树</p><h2 id="算法分析A"><a href="#算法分析A" class="headerlink" title="算法分析A"></a>算法分析A</h2><p>平衡二叉树是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。从平衡二叉树描述可以知道平衡二叉树是递归定义的。因此，判断一颗二叉树是否是平衡二叉树也可以通过递归来判断。具体判断过程如下：</p><ol><li>判断根节点左右子树高度差是否大于1</li><li>递归判断左右子树的左右子树高度差是否大于1</li></ol><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBlancedTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 判断根节点所在树是否平衡及递归判断左右子树是否平衡</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(height(root.left)-height(root.right))&lt;=<span class="number">1</span>&amp;&amp;isBlancedTree(root.left)&amp;&amp;isBlancedTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height(node.left),height(node.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法分析B"><a href="#算法分析B" class="headerlink" title="算法分析B"></a>算法分析B</h2><p>上述实现方法采用从上至下依次判断方式，判断过程中存在大量重复计算，因此存在优化空间。如果改为从下往上遍历，如果子树是平衡二叉树，则返回子树的高度；如果发现子树不是平衡二叉树，则直接停止遍历，这样至多只对每个结点访问一次。代码如下。</p><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBlancedTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据树高度计算函数返回结果判断是否平衡</span></span><br><span class="line">        <span class="keyword">return</span> height(root)!=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算左子树高度</span></span><br><span class="line">        <span class="keyword">int</span> leftHeight = height(node.left);</span><br><span class="line">        <span class="comment">// 若左子树高度返回-1说明左子树不平衡，直接返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(leftHeight==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算右子树高度</span></span><br><span class="line">        <span class="keyword">int</span> rightHeight = height(node.right);</span><br><span class="line">        <span class="comment">// 若右子树高度返回-1说明右子树不平衡，直接返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(rightHeight==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 根据左右子树高度差判断左右子树是否平衡，若不平衡返回-1，若平衡返回子树高度</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(leftHeight-rightHeight)&gt;<span class="number">1</span>?-<span class="number">1</span>:Math.max(leftHeight,rightHeight)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="求二叉树的直径"><a href="#求二叉树的直径" class="headerlink" title="求二叉树的直径"></a>求二叉树的直径</h1><h2 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树：</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">   / \   </span><br><span class="line">  4   5</span><br><span class="line">返回3, 它的长度是路径[4,2,1,3]或者[5,2,1,3]。</span><br></pre></td></tr></table></figure><h2 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h2><p>求一棵树两节点路径的最大值，创建一个全局变量保存最大直径。分别求出左右子树的最大深度，则经过根节点的直径值为左子树的最大深度加上右子树的最大深度，然后递归求解最终得到全局最大直径。</p><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxDiameter = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 求树的最大深度</span></span><br><span class="line">        maxDepth(root);</span><br><span class="line">        <span class="keyword">return</span> maxDiameter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 递归求解左子树最大深度</span></span><br><span class="line">        <span class="keyword">int</span> left = maxDepth(node.left);</span><br><span class="line">        <span class="comment">// 递归求解右子树最大深度</span></span><br><span class="line">        <span class="keyword">int</span> right = maxDepth(node.right);</span><br><span class="line">        <span class="comment">// 求经过当前节点的直径，并保存当前最大直径</span></span><br><span class="line">        maxDiameter = Math.max(maxDiameter,left+right);</span><br><span class="line">        <span class="comment">// 返回最大深度</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h1><h2 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h2><p>给定一个非空二叉树，返回其最大路径和。这里路径定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入 [1,2,3]</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><h2 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h2><p>此算法与求二叉树直径算法类似，求一棵树节点路径的最大和，创建一个全局变量保存最大路径和。分别求出左右子树的最大路径和，则经过根节点的直径值为左子树的最大路径和加上右子树的最大路径和再加上根节点的值，然后递归求解最终得到全局最大路径和。</p><h2 id="实现代码-4"><a href="#实现代码-4" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxPathSum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 求树的最大路径和</span></span><br><span class="line">        maxPathSumHelper(root);</span><br><span class="line">        <span class="keyword">return</span> maxPathSum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxPathSumHelper</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 递归求解左子树最大路径和</span></span><br><span class="line">        <span class="keyword">int</span> left = Math.max(maxPathSumHelper(node.left),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 递归求解右子树最大路径和</span></span><br><span class="line">        <span class="keyword">int</span> right = Math.max(maxPathSumHelper(node.right),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 求经过当前节点的最大路径和，并保存当前最大的路径和</span></span><br><span class="line">        maxPathSum = Math.max(maxPathSum,left+right+node.val);</span><br><span class="line">        <span class="comment">// 返回最大路径和</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h1><h2 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h2><p>这个算法题的出现背后有一个很有意思的故事：</p><blockquote><p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.</p></blockquote><p>大意是说某位大佬很厉害，谷歌公司90%的工程师都使用过他开发的软件，但这位大佬在面试时不能在白板上写出反转一颗二叉树的代码，所以谷歌就让他滚蛋了~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">用例示例：</span><br><span class="line">输入：</span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br><span class="line">输出：</span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><h2 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h2><p>树的算法一般都会涉及到递归求解，反转二叉树也不例外。我们可以用递归和迭代两种方式分别求解。递归需要找到子问题，反转一颗二叉树的子问题就是反转左子树，反转右子树，然后继续递归，直至子树为空。迭代求解需要借助一个队列保存访问节点，然后取出节点进行左右子节点交换后再将左右子节点放入队列依次迭代。</p><h2 id="实现代码-5"><a href="#实现代码-5" class="headerlink" title="实现代码"></a>实现代码</h2><ol><li>递归实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 递归反转左子树</span></span><br><span class="line">        TreeNode left = invertTree(root.left);</span><br><span class="line">        <span class="comment">// 递归反转右子树</span></span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        <span class="comment">// 交换根节点左右子树</span></span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>迭代实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 队列保存访问节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="comment">// 交换左右子节点</span></span><br><span class="line">            TreeNode temp = node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = temp;</span><br><span class="line">            <span class="comment">// 继续入队，进行下一轮迭代</span></span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1><h2 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><blockquote><p>对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">     3</span><br><span class="line">   /   \</span><br><span class="line">  5     1</span><br><span class="line"> / \   / \</span><br><span class="line">6   2 0   8</span><br><span class="line">   / \</span><br><span class="line">  7   4</span><br><span class="line"></span><br><span class="line">p=5, q=1</span><br><span class="line"></span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点5和节点1的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure><h2 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h2><p>分三种情况讨论。</p><ol><li>当根节点是p或q则根节点一定为最近公共祖先节点。</li><li>当左子树节点包含p或q中一个节点，右子树节点也包含p或q中另一个节点，则根节点为最近公共祖先节点。</li><li>左子树所有节点不包含p或q，则最近公共祖先节点存在于右子树中，反之存在于左子树中。</li><li>对上述条件进行递归可求得最终最近公共祖先节点。</li></ol><h2 id="实现代码-6"><a href="#实现代码-6" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 当根节点为p或q则最近公共祖先节点为根节点</span></span><br><span class="line">        <span class="keyword">if</span>(root==p||root==q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 求左子树的最近公共祖先节点</span></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="comment">// 求右子树的最近公共祖先节点</span></span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="comment">// 左右子树都不包含p和q的最近公共祖先节点则根节点为最近公共祖先节点</span></span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="keyword">null</span>&amp;&amp;right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 返回左子树或右子树包含的最近公共祖先节点</span></span><br><span class="line">            <span class="keyword">return</span> left==<span class="keyword">null</span>?right:left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="搜索二叉树转换为排序双向链表"><a href="#搜索二叉树转换为排序双向链表" class="headerlink" title="搜索二叉树转换为排序双向链表"></a>搜索二叉树转换为排序双向链表</h1><h2 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">     2</span><br><span class="line">   /   \</span><br><span class="line">  1     3</span><br><span class="line"></span><br><span class="line">输出: 双链表 [1，2，3]</span><br></pre></td></tr></table></figure><h2 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h2><p>采用递归实现树转链表，步骤如下：</p><ol><li>创建全局节点保存子树最右节点；</li><li>递归转换左子树；</li><li>拼接根节点至左子树末尾；</li><li>递归转换右子树；</li><li>拼接右子树至根节点后。</li><li>根据左子树转换后的左链表是否为空返回左链表头结点或根节点。</li></ol><h2 id="实现代码-7"><a href="#实现代码-7" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建全局节点保存左子树链表最后节点</span></span><br><span class="line">    TreeNode lastNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  TreeNode <span class="title">convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 递归访问到左子树叶子节点时说明可以开始转换链表，将最后节点值设为叶子节点并返回该叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            lastNode = root;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归转换左子树</span></span><br><span class="line">        TreeNode leftHead = convert(root.left);</span><br><span class="line">        <span class="comment">// 拼接根节点至左链表末尾</span></span><br><span class="line">        <span class="keyword">if</span>(leftHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lastNode.right = root;</span><br><span class="line">            root.left = lastNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新末尾节点</span></span><br><span class="line">        lastNode = root;</span><br><span class="line">        <span class="comment">// 递归转换右子树</span></span><br><span class="line">        TreeNode rightHead = convert(root.right);</span><br><span class="line">        <span class="comment">// 拼接右子树至根节点后</span></span><br><span class="line">        <span class="keyword">if</span>(rightHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            rightHead.left = root;</span><br><span class="line">            root.right = rightHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最终结果</span></span><br><span class="line">        <span class="keyword">return</span> leftHead==<span class="keyword">null</span>?root:leftHead;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="根据二叉树的前序遍历序列与中序遍历序列构建二叉树"><a href="#根据二叉树的前序遍历序列与中序遍历序列构建二叉树" class="headerlink" title="根据二叉树的前序遍历序列与中序遍历序列构建二叉树"></a>根据二叉树的前序遍历序列与中序遍历序列构建二叉树</h1><h2 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h2><p>给出一颗二叉树的前序遍历与中序遍历序列，重构出这颗二叉树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder = [9,3,15,20,7]</span><br><span class="line"></span><br><span class="line">返回二叉树:</span><br><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><h2 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h2><p>前序遍历的顺序是root-&gt;left-&gt;right，根据前序遍历可以确定根节点位置，但无法知道左子树与右子树的界限。而中序遍历的顺序left-&gt;root-&gt;right可根据根节点的位置确定左子树与右子树的界限。两者结合便可确定唯一的一颗二叉树。</p><h2 id="实现代码-8"><a href="#实现代码-8" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder==<span class="keyword">null</span>||inorder==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder,inorder,<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 采用递归的方式构建二叉树。递归构建二叉树过程中我们需要知道先序序列中当前根节点</span></span><br><span class="line">    <span class="comment">// 的位置preIndex,中序遍历中当前子树所有节点的位置区间</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> preIndex,inStart,inEnd)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归出口。当根节点位置大于先序序列长度或中序序列起始位置大于结束位置时，</span></span><br><span class="line">        <span class="comment">// 说明当前节点左子树或右子树为空，结束递归。</span></span><br><span class="line">        <span class="keyword">if</span>(preIndex&gt;preOrder.length-<span class="number">1</span>||inStart&gt;InEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按先序序列顺序创建根节点及子树根节点</span></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(preorder[preIndex]);</span><br><span class="line">        <span class="comment">// 保存根节点在中序序列中的位置</span></span><br><span class="line">        <span class="keyword">int</span> currIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到根节点在中序序列中的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==preorder[preIndex])&#123;</span><br><span class="line">                currIndex=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归创建左子树。根据先序遍历访问节点顺序root|left|right,可知左子树根节</span></span><br><span class="line">        <span class="comment">// 点位于先序序列当前根节点位置右边第一个位置，即preIndex+1,整个左子树在中</span></span><br><span class="line">        <span class="comment">// 序序列中的位置区间为当前中序序列起始位置到当前根节点在中序序列中的位置左边</span></span><br><span class="line">        <span class="comment">// 第一个位置,即[inStart,currIndex-1]。</span></span><br><span class="line">        node.left = buildTree(preorder,inorder,preIndex+<span class="number">1</span>,inStart,currIndex-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归创建右子树。根据先序遍历访问节点顺序root|left|right,可知右子树根节</span></span><br><span class="line">        <span class="comment">// 点位于先序序列当前根节点位置加上左子树节点个数再加一，左子树节点个数又等于</span></span><br><span class="line">        <span class="comment">// 中序序列中根节点的位置减去当前起始位置即currIndex-inStart,因此右子树根</span></span><br><span class="line">        <span class="comment">// 节点位置为preIndex+currIndex-inStart+1,整个右子树在中序序列中的位置</span></span><br><span class="line">        <span class="comment">// 区间为当前根节点在中序序列中的位置加一到当前中序序列结束位置即</span></span><br><span class="line">        <span class="comment">// [currIndex+1,inEnd]。</span></span><br><span class="line">        node.right = buildTree(preorder,inorder,preIndex+currIndex-inStart+<span class="number">1</span>,currIndex+<span class="number">1</span>,inEnd);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="根据二叉树的中序遍历序列与后序遍历序列构建二叉树"><a href="#根据二叉树的中序遍历序列与后序遍历序列构建二叉树" class="headerlink" title="根据二叉树的中序遍历序列与后序遍历序列构建二叉树"></a>根据二叉树的中序遍历序列与后序遍历序列构建二叉树</h1><h2 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h2><p>给出一颗二叉树的中序遍历与后序遍历序列，重构出这颗二叉树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inorder = [9,3,15,20,7]</span><br><span class="line">postorder = [9,15,7,20,3]</span><br><span class="line"></span><br><span class="line">返回二叉树:</span><br><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><h2 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h2><p>后序遍历的顺序是left-&gt;right-&gt;root，根据后序遍历可以确定根节点位置，但无法知道左子树与右子树的界限。而中序遍历的顺序left-&gt;root-&gt;right可根据根节点的位置确定左子树与右子树的界限。两者结合便可确定唯一的一颗二叉树。</p><h2 id="实现代码-9"><a href="#实现代码-9" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder==<span class="keyword">null</span>||postorder==<span class="keyword">null</span>||inorder.length!=postorder) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 采用hashmap存放inorder序列与对应下标，可直接定位根节点在中序序列中位置</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            hm.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTree(inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>,postorder,<span class="number">0</span>,postorder.length-<span class="number">1</span>,hm);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 采用递归的方式构建二叉树。递归构建二叉树过程中我们需要知道后序序列中当前根节点</span></span><br><span class="line">    <span class="comment">// 的位置pe,中序遍历中当前子树所有节点的位置区间</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder,<span class="keyword">int</span> is,<span class="keyword">int</span> ie, <span class="keyword">int</span>[] postorder, ps,pe)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归出口。当中序序列起始位置大于结束位置或后序遍历起始位置大于结束位置时，</span></span><br><span class="line">        <span class="comment">// 说明当前节点左子树或右子树为空，结束递归。</span></span><br><span class="line">        <span class="keyword">if</span>(is&gt;ie||ps&gt;pe)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按先序序列顺序创建根节点及子树根节点</span></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(postorder[pe]);</span><br><span class="line">        <span class="comment">// 获取根节点在中序序列中的位置</span></span><br><span class="line">        <span class="keyword">int</span> currIndex= hm.get(postorder[pe]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归创建左子树。左子树在中序遍历序列中区间[is,currIndex-1]，在后序遍历序列区间[ps,ps+currIndex-is-1]</span></span><br><span class="line">        node.left = buildTree(inorder,is,currIndex-<span class="number">1</span>,postorder,ps,ps+currIndex-is-<span class="number">1</span>,hm);</span><br><span class="line">        <span class="comment">// 递归创建右子树。右子树在中序遍历序列中区间[currIndex+1,ie]，在后序遍历序列区间[ps+currIndex-is,pe-1]</span></span><br><span class="line">        node.right = buildTree(inorder,currIndex+<span class="number">1</span>,ie,postorder,ps+currIndex-is,pe-<span class="number">1</span>,hm);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="根据二叉树的前序遍历序列与后序遍历序列构建二叉树"><a href="#根据二叉树的前序遍历序列与后序遍历序列构建二叉树" class="headerlink" title="根据二叉树的前序遍历序列与后序遍历序列构建二叉树"></a>根据二叉树的前序遍历序列与后序遍历序列构建二叉树</h1><h2 id="算法描述-9"><a href="#算法描述-9" class="headerlink" title="算法描述"></a>算法描述</h2><p>给出一颗二叉树的前序遍历与中序遍历序列，重构出这颗二叉树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pre = [1,2,4,5,3,6,7]</span><br><span class="line">post = [4,5,2,6,7,3,1]</span><br><span class="line"></span><br><span class="line">返回二叉树:</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">   / \   / \</span><br><span class="line">  4   5 6   7</span><br></pre></td></tr></table></figure><h2 id="算法分析-8"><a href="#算法分析-8" class="headerlink" title="算法分析"></a>算法分析</h2><p>后序遍历的顺序是left-&gt;right-&gt;root，根据后序遍历可以确定根节点位置，但无法知道左子树与右子树的界限。而先序遍历的顺序root-&gt;left-&gt;right可根据根节点在后序序列中的位置确定左子树与右子树的界限。两者结合便可确定一颗二叉树(非唯一)。</p><h2 id="实现代码-10"><a href="#实现代码-10" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder==<span class="keyword">null</span>||postorder==<span class="keyword">null</span>||preorder.length!=postorder) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 采用hashmap存放postorder序列与对应下标，可直接定位子树根节点在后序序列中位置</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;postorder.length;i++)&#123;</span><br><span class="line">            hm.put(postorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,postorder,<span class="number">0</span>,postorder.length-<span class="number">1</span>,hm);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 采用递归的方式构建二叉树。递归构建二叉树过程中我们需要知道后序序列中子树根节点所在位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder,<span class="keyword">int</span> preStart,<span class="keyword">int</span> preEnd, <span class="keyword">int</span>[] postorder, postStart,postEnd)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(preStart&gt;preEnd||postStart&gt;postEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(preStart==preEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        <span class="comment">// 左子树根节点在先序序列中位置</span></span><br><span class="line">        <span class="keyword">int</span> subLeftRootIdx = preStart+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 左子树根节点在后序序列中位置</span></span><br><span class="line">        <span class="keyword">int</span> subLeftRootPostIdx = hm.get(subLeftRootIdx)</span><br><span class="line">        <span class="comment">// 左子树在先序序列中区间结束位置    </span></span><br><span class="line">        <span class="keyword">int</span> subLeftEndPreIdx = subLeftRootIdx+subLeftRootPostIdx-postStart</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归创建左子树。左子树在先序遍历序列中区间[preStart+1,subLeftEndPreIdx]，在后序遍历序列区间[ps,subLeftRootPostIdx]</span></span><br><span class="line">        node.left = buildTree(preorder,preStart+<span class="number">1</span>,subLeftEndPreIdx,postorder,ps,subLeftRootPostIdx,hm);</span><br><span class="line">        <span class="comment">// 递归创建右子树。右子树在中序遍历序列中区间[subLeftEndPreIdx+1,preEnd]，在后序遍历序列区间[subLeftRootPostIdx+1,pe-1]</span></span><br><span class="line">        node.right = buildTree(preorder,subLeftEndPreIdx+<span class="number">1</span>,preEnd,postorder,subLeftRootPostIdx+<span class="number">1</span>,pe-<span class="number">1</span>,hm);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;树是计算机领域经常用到的一种数据结构，因为树的定义是递归的，因此，树相关的算法也大都涉及到递归求解。树有很多种类型，如二叉树、BST树、红黑
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://acmen.club/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://acmen.club/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>手撕单例模式</title>
    <link href="http://acmen.club/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%89%8B%E6%92%95%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://acmen.club/设计模式/手撕单例模式/</id>
    <published>2019-07-31T14:25:10.000Z</published>
    <updated>2019-08-04T15:52:39.430Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是设计模式里面相对比较简单的一种模式，这里的简单是说单例模式的代码逻辑简单，但深究起来，它里面涉及到的知识还是很多的。单例模式有很多种实现方式，有线程不安全的单例模式，有加锁单例模式，有双重检查加锁单例模式，有基于volatile的双重检查加锁单例模式，有基于类初始化的单例模式。那么这么多种单例模式都有什么区别呢？下面，我们对这些单例模式进行一一分析。</p><hr><h1 id="线程不安全的单例模式"><a href="#线程不安全的单例模式" class="headerlink" title="线程不安全的单例模式"></a>线程不安全的单例模式</h1><p>线程不安全的单例模式是单例模式最简单的实现方式，这种实现方式只推荐用来对单例模式进行理解，不推荐用于应用程序的开发中（单线程程序可以）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非线程安全的单例模式实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单例实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UnsafeSingleton singletonInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化，禁止外部创建单例类</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UnsafeSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UnsafeSingleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果单例对象还没有创建，则创建，否则直接返回已创建的单例对象</span></span><br><span class="line">        <span class="keyword">if</span>(singletonInstance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 多线程情况下这里会造成多个线程创建新对象，所以这种单例模式是线程不安全的</span></span><br><span class="line">            singletonInstance = <span class="keyword">new</span> UnsafeSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="加锁的单例模式"><a href="#加锁的单例模式" class="headerlink" title="加锁的单例模式"></a>加锁的单例模式</h1><p>这里加锁加是指在方法前加synchronized关键字，这种方式避免了多线程环境下对象的访问异常，缺点是每次获得实例均需加锁造成程序运行效率低下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单例实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizedSingleton singletonInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化，禁止外部创建单例类</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SynchronizedSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁获取单例对象,不论实例是否创建，访问时均要加锁，效率较低</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SynchronizedSingleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果单例对象还没有创建，则创建，否则直接返回已创建的单例对象</span></span><br><span class="line">        <span class="keyword">if</span>(singletonInstance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            singletonInstance = <span class="keyword">new</span> SynchronizedSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双重检查加锁的单例模式"><a href="#双重检查加锁的单例模式" class="headerlink" title="双重检查加锁的单例模式"></a>双重检查加锁的单例模式</h1><p>为了提高程序获取单例对象效率，将synchronized移至方法内部，只有当单例对象还未创建时才加锁创建对象，极大提升了访问效率。但这里存在线程安全问题，具体分析见代码注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCLSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单例实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DCLSingleton singletonInstance;</span><br><span class="line">    <span class="comment">// 构造方法私有化，禁止外部创建单例类</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DCLSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*通过双重检查加锁方式获取单例实例，这里将synchronized移到了方法内部，只有在单</span></span><br><span class="line"><span class="comment">    例对象还未创建的时候才会加锁，提高了对象获取效率，这里需要特别注意的一点就是单例对</span></span><br><span class="line"><span class="comment">    象创建过程是线程不安全的，可能在新建对象还未初始化完毕，其他线程就可能访问到这个单</span></span><br><span class="line"><span class="comment">    例对象，从而造成数据错误*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DCLSingleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果单例对象还没有创建，则创建，否则直接返回已创建的单例对象</span></span><br><span class="line">        <span class="keyword">if</span>(singletonInstance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DCLSingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singletonInstance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    singletonInstance = <span class="keyword">new</span> DCLSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="volatile-双重检查加锁的单例模式"><a href="#volatile-双重检查加锁的单例模式" class="headerlink" title="volatile+双重检查加锁的单例模式"></a>volatile+双重检查加锁的单例模式</h1><p>仅仅是双重检查加锁在多线程环境下会造成访问到不完整的对象，那么针对这个问题，要确保每次单例对象创建完成其他线程才能访问，则必须要禁止JVM的指令重排序，volatile关键字正好提供了这样的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCLAndVolatileSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单例实例,注意此处声明单例对象为volatile，这使得该对象具有内存可见性，以及禁止JVM对其进行指令重排序，从而保证该实例始终是预期的结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DCLAndVolatileSingleton singletonInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化，禁止外部创建单例类</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DCLAndVolatileSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过双重检查加锁方式获取单例实例，这里将synchronized移到了方法内部，只有在单</span></span><br><span class="line"><span class="comment">    例对象还未创建的时候才会加锁提高了对象获取效率，这里因为单例对象被声明为</span></span><br><span class="line"><span class="comment">    volatile，所以不会出现对象逃逸，在多线程环境下，该对象始终都是初始化完成后的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DCLAndVolatileSingleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果单例对象还没有创建，则创建，否则直接返回已创建的单例对象</span></span><br><span class="line">        <span class="keyword">if</span>(singletonInstance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DCLAndVolatileSingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singletonInstance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    singletonInstance = <span class="keyword">new</span> DCLAndVolatileSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于类初始化的单例模式"><a href="#基于类初始化的单例模式" class="headerlink" title="基于类初始化的单例模式"></a>基于类初始化的单例模式</h1><p>JVM在类的初始化阶段，会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。因此，基于这个特性，可以实现另一种线程安全的单例模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> StaticClassSingleton staticClassSingleton = <span class="keyword">new</span> StaticClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化，禁止外部创建单例类</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 首次执行该方法时将初始化InstanceHolder类,初始化这个类的过程JVM负责保证最终</span></span><br><span class="line">    <span class="comment">// 只有一个线程可以成功完成初始化，从而确保返回的对象是单例的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticClassSingleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.staticClassSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过对每一种单例模式的分析与实现，最终我们发现，只有最后两种单例模式符合开发的要求，因此，我们在自己的应用程序中实现单例模式时应采用后面两种。由于最后一种方式只能返回静态的单例对象，所以当我们需要非静态的单例对象时只能采用volatile+双重检查加锁的方式来实现。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单例模式是设计模式里面相对比较简单的一种模式，这里的简单是说单例模式的代码逻辑简单，但深究起来，它里面涉及到的知识还是很多的。单例模式有很多种实现方式，有线程不安全的单例模式，有加锁单例模式，有双重检查加锁单例模式，有基于volatile的双重检查加锁单例模式，有基于类初始
      
    
    </summary>
    
      <category term="设计模式" scheme="http://acmen.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="手撕代码" scheme="http://acmen.club/tags/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>手撕LRUCache</title>
    <link href="http://acmen.club/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%89%8B%E6%92%95LRUCache/"/>
    <id>http://acmen.club/数据结构与算法/手撕LRUCache/</id>
    <published>2019-07-29T14:53:31.000Z</published>
    <updated>2019-07-30T15:03:04.241Z</updated>
    
    <content type="html"><![CDATA[<p>LRUCache中文名称最近最少使用缓存，该类型缓存用途广泛，主要用于保存近期经常使用的数据。LRUCache的实现方式多种多样，但效率最高的只有一种，那就是LinkedList与HashMap配合实现LRUCache。</p><h1 id="LRUCache实现原理分析"><a href="#LRUCache实现原理分析" class="headerlink" title="LRUCache实现原理分析"></a>LRUCache实现原理分析</h1><ul><li><p>众所周知，LRUCache的一个最大特点就是缓存里的数据永远都是最近访问过的数据。这样设计是因为计算机内部的数据访问具有空间局部性。如果把最近访问过得数据放到缓存，那么缓存命中的几率会很大，这也大大提升了程序的运行效率。那么，底层该采用那种数据结构才能实现LRUCache缓存呢？</p></li><li><p>缓存的基本功能是数据访问，我们为了提高数据访问效率一般都采用HashMap结构保存数据。同时，为了保存数据的访问状态信息，我们采用链表来保证数据永远是最近访问过的(每次访问数据后将其移动至链表头结点)。这里为了操作方便，采用带首尾节点的双链表实现数据状态保存。</p></li><li><p>当然，Cache是很宝贵的资源，因为它们的存储空间一般都不大。所以还得设置变量标识缓存总容量大小以及当前数据大小。当缓存满时，淘汰最近最少访问的数据，即链表尾部的数据(因为我们每次添加或访问数据后，该数据都会被放至表头)。</p></li></ul><h1 id="LRUCache代码实现"><a href="#LRUCache代码实现" class="headerlink" title="LRUCache代码实现"></a>LRUCache代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,DLinkedNode&gt; map;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        head = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        head.prev = <span class="keyword">null</span>;</span><br><span class="line">        tail = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        tail.next = <span class="keyword">null</span>;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        head.next = tail;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        DLinkedNode node = map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        DLinkedNode node = map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            DLinkedNode newNode = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">            newNode.key = key;</span><br><span class="line">            newNode.value = value;</span><br><span class="line">            map.put(key,newNode);</span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;capacity)&#123;</span><br><span class="line">                removeTail();</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        remove(tail.prev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(DLinkedNode node)</span></span>&#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode node)</span></span>&#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.next.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode node)</span></span>&#123;</span><br><span class="line">        remove(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LRUCache中文名称最近最少使用缓存，该类型缓存用途广泛，主要用于保存近期经常使用的数据。LRUCache的实现方式多种多样，但效率最高的只有一种，那就是LinkedList与HashMap配合实现LRUCache。&lt;/p&gt;&lt;h1 id=&quot;LRUCache实现原理分析&quot;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://acmen.club/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="手撕代码" scheme="http://acmen.club/tags/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown语法速记</title>
    <link href="http://acmen.club/%E6%95%88%E7%8E%87/MarkDown%E8%AF%AD%E6%B3%95%E9%80%9F%E8%AE%B0/"/>
    <id>http://acmen.club/效率/MarkDown语法速记/</id>
    <published>2019-07-27T14:04:46.000Z</published>
    <updated>2019-07-30T14:35:52.075Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。下面就是MarkDown的常用标记语法的介绍，作为很受欢迎的写作工具，极大的提升我们日常的写作效率。语法虽然都比较简单，但短时间内都记住也是件比较困难的事情，这篇博客可以当做MarkDown语法工具书，写作过程中根据需求随时查阅，用的多了，自然就熟记于心了。</p><h1 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># H1</span><br><span class="line">## H2</span><br><span class="line">### H3</span><br><span class="line">#### H4</span><br><span class="line">##### H5</span><br><span class="line">###### H6</span><br><span class="line"></span><br><span class="line">Alternatively, for H1 and H2, an underline-ish style:</span><br><span class="line"></span><br><span class="line">Alt-H1</span><br><span class="line">======</span><br><span class="line"></span><br><span class="line">Alt-H2</span><br><span class="line">------</span><br></pre></td></tr></table></figure><h1 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h1><h2 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h2><h3 id="H3"><a href="#H3" class="headerlink" title="H3"></a>H3</h3><h4 id="H4"><a href="#H4" class="headerlink" title="H4"></a>H4</h4><h5 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h5><h6 id="H6"><a href="#H6" class="headerlink" title="H6"></a>H6</h6><p>Alternatively, for H1 and H2, an underline-ish style:</p><h1 id="Alt-H1"><a href="#Alt-H1" class="headerlink" title="Alt-H1"></a>Alt-H1</h1><hr><h2 id="Alt-H2"><a href="#Alt-H2" class="headerlink" title="Alt-H2"></a>Alt-H2</h2><hr><h1 id="Emphasis"><a href="#Emphasis" class="headerlink" title="Emphasis"></a>Emphasis</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Emphasis, aka italics, with *asterisks* or _underscores_.</span><br><span class="line"></span><br><span class="line">Strong emphasis, aka bold, with **asterisks** or __underscores__.</span><br><span class="line"></span><br><span class="line">Combined emphasis with **asterisks and _underscores_**.</span><br><span class="line"></span><br><span class="line">Strikethrough uses two tildes. ~~Scratch this.~~</span><br></pre></td></tr></table></figure><p>Emphasis, aka italics, with <em>asterisks</em> or <em>underscores</em>.</p><p>Strong emphasis, aka bold, with <strong>asterisks</strong> or <strong>underscores</strong>.</p><p>Combined emphasis with <strong>asterisks and <em>underscores</em></strong>.</p><p>Strikethrough uses two tildes. <del>Scratch this.</del></p><h1 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. First ordered list item</span><br><span class="line">2. Another item</span><br><span class="line">  * Unordered sub-list. </span><br><span class="line">1. Actual numbers don&apos;t matter, just that it&apos;s a number</span><br><span class="line">  1. Ordered sub-list</span><br><span class="line">4. And another item.  </span><br><span class="line">   </span><br><span class="line">   Some text that should be aligned with the above item.</span><br><span class="line"></span><br><span class="line">* Unordered list can use asterisks</span><br><span class="line">- Or minuses</span><br><span class="line">+ Or pluses</span><br></pre></td></tr></table></figure><ol><li>First ordered list item</li><li>Another item<ul><li>Unordered sub-list.</li></ul></li><li>Actual numbers don’t matter, just that it’s a number<ol><li>Ordered sub-list</li></ol></li><li><p>And another item.</p><p>Some text that should be aligned with the above item.</p></li></ol><ul><li>Unordered list can use asterisks</li></ul><ul><li>Or minuses</li></ul><ul><li>Or pluses</li></ul><h1 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h1><p>There are two ways to create links.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[I&apos;m an inline-style link](https://www.google.com)</span><br><span class="line"></span><br><span class="line">[I&apos;m a reference-style link][Arbitrary case-insensitive reference text]</span><br><span class="line"></span><br><span class="line">[You can use numbers for reference-style link definitions][1]</span><br><span class="line"></span><br><span class="line">Or leave it empty and use the [link text itself].</span><br><span class="line"></span><br><span class="line">URLs and URLs in angle brackets will automatically get turned into links. </span><br><span class="line">http://www.example.com or &lt;http://www.example.com&gt; and sometimes </span><br><span class="line">example.com (but not on Github, for example).</span><br><span class="line"></span><br><span class="line">Some text to show that the reference links can follow later.</span><br><span class="line"></span><br><span class="line">[arbitrary case-insensitive reference text]: https://www.mozilla.org</span><br><span class="line">[1]: http://slashdot.org</span><br><span class="line">[link text itself]: http://www.reddit.com</span><br></pre></td></tr></table></figure><p><a href="https://www.google.com" target="_blank" rel="noopener">I’m an inline-style link</a></p><p><a href="https://www.mozilla.org" title="mozilla" target="_blank" rel="noopener">I’m a reference-style link</a></p><p><a href="http://slashdot.org" title="slashdot" target="_blank" rel="noopener">You can use numbers for reference-style link definitions</a></p><p>Or leave it empty and use the <a href="http://www.reddit.com" title="reddit" target="_blank" rel="noopener">link text itself</a>.</p><p>URLs and URLs in angle brackets will automatically get turned into links. <a href="http://www.example.com" target="_blank" rel="noopener">http://www.example.com</a> or <a href="http://www.example.com" target="_blank" rel="noopener">http://www.example.com</a> and sometimes example.com (but not on Github, for example).</p><p>Some text to show that the reference links can follow later.</p><h1 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Here&apos;s our logo (hover to see the title text):</span><br><span class="line"></span><br><span class="line">Inline-style: </span><br><span class="line">![alt text](https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png &quot;Logo Title Text 1&quot;)</span><br><span class="line"></span><br><span class="line">Reference-style: </span><br><span class="line">![alt text][logo]</span><br><span class="line"></span><br><span class="line">[logo]: https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png &quot;Logo Title Text 2&quot;</span><br></pre></td></tr></table></figure><p>Here’s our logo (hover to see the title text):</p><p>Inline-style:<br><img src="https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png" alt="alt text" title="Logo Title Text 1"></p><p>Reference-style:<br><img src="https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png" alt="alt text" title="Logo Title Text 2"></p><h1 id="Code-and-Syntax-Highlighting"><a href="#Code-and-Syntax-Highlighting" class="headerlink" title="Code and Syntax Highlighting"></a>Code and Syntax Highlighting</h1><p>Code blocks are part of the Markdown spec, but syntax highlighting isn’t. However, many renderers – like Github’s and Markdown Here – support syntax highlighting. Which languages are supported and how those language names should be written will vary from renderer to renderer. Markdown Here supports highlighting for dozens of languages (and not-really-languages, like diffs and HTTP headers); to see the complete list, and how to write the language names, see the highlight.js demo page.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Inline `code` has `back-ticks around` it.</span><br></pre></td></tr></table></figure><p>Inline <code>code</code> has <code>back-ticks</code> around it.</p><p>Blocks of code are either fenced by lines with three back-ticks ```(采用’\‘转义), or are indented with four spaces. I recommend only using the fenced code blocks – they’re easier and only they support syntax highlighting.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">​```(前面用````包围可显示)javascript</span><br><span class="line">var s = &quot;JavaScript syntax highlighting&quot;;</span><br><span class="line">alert(s);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">s = &quot;Python syntax highlighting&quot;</span><br><span class="line">print s</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">No language indicated, so no syntax highlighting. </span><br><span class="line">But let&apos;s throw in a &lt;b&gt;tag&lt;/b&gt;.</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>​</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = &quot;JavaScript syntax highlighting&quot;;</span><br><span class="line">alert(s);</span><br></pre></td></tr></table></figure><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"Python syntax highlighting"</span></span><br><span class="line"><span class="keyword">print</span> s</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No language indicated, so no syntax highlighting in Markdown Here (varies on Github). </span><br><span class="line">But let&apos;s throw in a &lt;b&gt;tag&lt;/b&gt;.</span><br></pre></td></tr></table></figure><h1 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h1><p>Tables aren’t part of the core Markdown spec, but they are part of GFM and Markdown Here supports them. They are an easy way of adding tables to your email – a task that would otherwise require copy-pasting from another application.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Colons can be used to align columns.</span><br><span class="line"></span><br><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- |:-------------:| -----:|</span><br><span class="line">| col 3 is      | right-aligned | $1600 |</span><br><span class="line">| col 2 is      | centered      |   $12 |</span><br><span class="line">| zebra stripes | are neat      |    $1 |</span><br><span class="line"></span><br><span class="line">There must be at least 3 dashes separating each header cell.</span><br><span class="line">The outer pipes (|) are optional, and you don&apos;t need to make the </span><br><span class="line">raw Markdown line up prettily. You can also use inline Markdown.</span><br><span class="line"></span><br><span class="line">Markdown | Less | Pretty</span><br><span class="line">--- | --- | ---</span><br><span class="line">*Still* | `renders` | **nicely**</span><br><span class="line">1 | 2 | 3</span><br><span class="line">Colons can be used to align columns.</span><br></pre></td></tr></table></figure><p></p><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table><p>There must be at least 3 dashes separating each header cell.<br>The outer pipes (|) are optional, and you don’t need to make the<br>raw Markdown line up prettily. You can also use inline Markdown.</p><table><thead><tr><th>Markdown</th><th>Less</th><th>Pretty</th></tr></thead><tbody><tr><td><em>Still</em></td><td><code>renders</code></td><td><strong>nicely</strong></td></tr><tr><td>1</td><td>2</td><td>3</td></tr></tbody></table><p>Colons can be used to align columns.</p><h1 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; Blockquotes are very handy in email to emulate reply text.</span><br><span class="line">&gt; This line is part of the same quote.</span><br><span class="line"></span><br><span class="line">Quote break.</span><br><span class="line"></span><br><span class="line">&gt; This is a very long line that will still be quoted properly when it wraps. Oh boy let&apos;s keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can *put* **Markdown** into a blockquote.</span><br></pre></td></tr></table></figure><blockquote><p>Blockquotes are very handy in email to emulate reply text.<br>This line is part of the same quote.</p></blockquote><p>Quote break.</p><blockquote><p>This is a very long line that will still be quoted properly when it wraps. Oh boy let’s keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can <em>put</em> <strong>Markdown</strong> into a blockquote.</p></blockquote><h1 id="Inline-HTML"><a href="#Inline-HTML" class="headerlink" title="Inline HTML"></a>Inline HTML</h1><p>You can also use raw HTML in your Markdown, and it’ll mostly work pretty well.<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Definition list<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Is something people use sometimes.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Markdown in HTML<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Does *not* work **very** well. Use HTML <span class="tag">&lt;<span class="name">em</span>&gt;</span>tags<span class="tag">&lt;/<span class="name">em</span>&gt;</span>.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><dl><br><dt>Definition list</dt><br><dd>Is something people use sometimes.</dd><br><br><dt>Markdown in HTML</dt><br><dd>Does <em>not</em> work <strong>very</strong> well. Use HTML <em>tags</em>.</dd><br></dl><h1 id="Horizontal-Rule"><a href="#Horizontal-Rule" class="headerlink" title="Horizontal Rule"></a>Horizontal Rule</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Three or more...</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">Hyphens</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">Asterisks</span><br><span class="line"></span><br><span class="line">___</span><br><span class="line"></span><br><span class="line">Underscores</span><br></pre></td></tr></table></figure><p>Three or more…</p><hr><p>Hyphens</p><hr><p>Asterisks</p><hr><p>Underscores</p><h1 id="Line-Breaks"><a href="#Line-Breaks" class="headerlink" title="Line Breaks"></a>Line Breaks</h1><p>My basic recommendation for learning how line breaks work is to experiment and discover – hit<enter>once (i.e., insert one newline), then hit it twice (i.e., insert two newlines), see what happens. You’ll soon learn to get what you want. “Markdown Toggle” is your friend.</enter></p><p>Here are some things to try out:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Here&apos;s a line for us to start with.</span><br><span class="line"></span><br><span class="line">This line is separated from the one above by two newlines, so it will be a *separate paragraph*.</span><br><span class="line"></span><br><span class="line">This line is also a separate paragraph, but...</span><br><span class="line">This line is only separated by a single newline, so it&apos;s a separate line in the *same paragraph*.</span><br></pre></td></tr></table></figure><p></p><p>Here’s a line for us to start with.</p><p>This line is separated from the one above by two newlines, so it will be a separate paragraph.</p><p>This line is also begins a separate paragraph, but…<br>This line is only separated by a single newline, so it’s a separate line in the same paragraph.</p><p>(Technical note: Markdown Here uses GFM line breaks, so there’s no need to use MD’s two-space line breaks.)</p><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]: <a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Here-Cheatsheet" target="_blank" rel="noopener">https://github.com/adam-p/markdown-here/wiki/Markdown-Here-Cheatsheet</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。下面就是MarkDown的常用标记语法的介绍，作为很受欢迎的写作工具，极大的提升我们日常的写作效率。语法虽然都比较简单，但短时间内都记住也是件比较困难的事情，
      
    
    </summary>
    
      <category term="效率" scheme="http://acmen.club/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="效率提升" scheme="http://acmen.club/tags/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>手撕一个生产者消费者模型</title>
    <link href="http://acmen.club/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%89%8B%E6%92%95%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <id>http://acmen.club/数据结构与算法/手撕生产者消费者模型/</id>
    <published>2019-05-08T14:04:46.000Z</published>
    <updated>2019-07-28T03:33:13.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>生产者-消费者模型是在计算机各个领域经常用到的一个模型，那么如何简单实现这个模型呢?</p><hr><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><ul><li><p>首先，需要一个地方存放生产者生产与消费者消费的资源，简单起见我们用一个Object数组当做资源池来保存资源。</p></li><li><p>其次，我们知道资源池是有大小限制的，那么生产者向资源池添加资源时就必须考虑资源池是否填满。同理，消费者消费资源时也必须考虑资源池里有没有资源可供消费，即资源池是否为空。那么我们如何知道资源池是满还是空呢？当然是给资源池添加两个属性来表示资源池的状态：notFull表示非满状态，notEmpty表示非空状态。</p></li></ul><ul><li>最后，资源池是一个临界资源，不能同时被生产者消费者访问(存在多个生产者和消费者。若同时访问会造成资源数据错误)。我们需要一把锁来控制资源池的访问。这里采用ReentryLock来进行访问控制。</li></ul><ul><li>综上，采用带两个条件的ReentryLock来实现生产者消费者模型最合适不过了。下面就是实现代码。</li></ul><hr><h1 id="生产者-消费者模型代码实现"><a href="#生产者-消费者模型代码实现" class="headerlink" title="生产者-消费者模型代码实现"></a>生产者-消费者模型代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumerModel</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object[] resources;</span><br><span class="line"><span class="comment">// 添加下标，删除下标，数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> addIndex, removeIndex, count;</span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentryLock();</span><br><span class="line"><span class="keyword">private</span> Condition notFull = lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProducerAndConsumerModel</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">resources = <span class="keyword">new</span> Object[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者生产资源，若资源池已满，则生产者进入等待状态，直到有空位</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResource</span><span class="params">(T resource)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(count==Object.length)&#123;</span><br><span class="line">notFull.await();</span><br><span class="line">&#125;</span><br><span class="line">resources[addIndex] = resource;</span><br><span class="line"><span class="keyword">if</span>(++addIndex==Object.length)&#123;</span><br><span class="line">addIndex = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">++count;</span><br><span class="line">notEmpty.signal();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者消费资源，若资源池为空，则消费者进入等待状态，直到资源池有资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">removeResource</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">notEmpty.await();</span><br><span class="line">&#125;</span><br><span class="line">Object resource = resources[removeIndex];</span><br><span class="line"><span class="keyword">if</span>(++removeIndex==resources.length)&#123;</span><br><span class="line">removeIndex==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">--count;</span><br><span class="line">notFull.signal();</span><br><span class="line"><span class="keyword">return</span> (T) resource;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;生产者-消费者模型是在计算机各个领域经常用到的一个模型，那么如何简单实现这个模型呢?&lt;/p&gt;&lt;hr&gt;&lt;h1 id=&quot;问题分析&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://acmen.club/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="手撕代码" scheme="http://acmen.club/tags/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[手撕一个生产者消费者模型]]></title>
    <url>%2F2019%2F05%2F08%2F%E6%89%8B%E6%92%95%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[生产者-消费者模型在计算机各个领域经常用到的一个经典模型，那么如何实现一个简单的生产者-消费者模型呢？问题分析首先，需要一个地方存放生产者生产与消费者消费的资源，简单起见我们用一个Object数组当做资源池来保存资源。其次，我们知道资源池是有大小限制的，那么生产者向资源池添加资源时就必须考虑资源池是否填满。同理，消费者消费资源时也必须考虑资源池里有没有资源可供消费，即资源池是否为空。那么我们如何知道资源池是满还是空呢？当然是给资源池添加两个属性来表示资源池的状态：notFull表示非满状态，notEmpty表示非空状态。最后，资源池是一个临界资源，不能同时被生产者消费者访问(存在多个生产者和消费者。若同时访问会造成资源数据错误)。我们需要一把锁来控制资源池的访问。这里采用ReentryLock来进行访问控制。综上，采用带两个条件的ReentryLock来实现生产者消费者模型最合适不过了。下面就是实现代码。生产者-消费者模型12345678910111213141516171819202122232425262728293031public class ProducerAndConsumerModel&lt;T&gt; &#123; private Object[] resources; // 添加下标，删除下标，数量 private int addIndex, removeIndex, count; private Lock lock = new ReentryLock(); private Condition notFull = lock.newCondition(); private Condition notEmpty = lock.newCondition(); public ProducerAndConsumerModel(int size)&#123; resources = new Object[size]; &#125; public void addResource(T resource) throws InterruptedException&#123; lock.lock(); try&#123; while(count==Object.length)&#123; notFull.await(); &#125; resources[addIndex] = resource; if(++addIndex==Object.length)&#123; addIndex = 0; &#125; ++count; notEmpty.signal(); &#125;finally&#123; lock.unlock(); &#125; &#125; //TODO remove()&#125;More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
  </entry>
</search>
